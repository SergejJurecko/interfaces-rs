extern crate gcc;
extern crate handlebars as hbs;
extern crate rustc_serialize;

use std::collections::BTreeMap;
use std::convert::From;
use std::fs::File;
use std::io::{self, Read};
use std::path::{Path, PathBuf};
use std::process::exit;

use std::env;

use rustc_serialize::json::{Json, ToJson};

fn main() {
    let in_path = Path::new("src").join("constants.c.in");
    let out_path = PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("constants.c");

    // Template the file.
    if let Err(e) = template_file(&in_path, &out_path) {
        println!("Error creating `constants.c` from template");
        println!("-> {:?}", e);
        exit(1);
    }

    // Build the final library
    let mut cfg = gcc::Build::new();

    let helpers_path = Path::new("src").join("helpers.c");
    cfg.file(&out_path)
       .file(&helpers_path)
       .compile("libinterfaces.a");
}

fn template_file(in_path: &PathBuf, out_path: &PathBuf) -> Result<(), Error> {
    // Open and read the file.
    let mut f = try!(File::open(in_path));
    let mut s = String::new();
    try!(f.read_to_string(&mut s));

    let mut handlebars = hbs::Handlebars::new();
    try!(handlebars.register_template_string("template", s));

    let mut f = try!(File::create(out_path));

    let data = make_data();
    let context = hbs::Context::wraps(&data);
    try!(handlebars.renderw("template", context.data(), &mut f));

    Ok(())
}

fn make_data() -> BTreeMap<String, Json> {
    let mut data = BTreeMap::new();

    // These constants are "dynamically" generated by compiling a C file that includes their value
    // and then including that in the final build.  See `constants.rs` for a function that can be
    // used to retrieve them.
    let names: &[&str] = &[
        // IOCTLs
        "SIOCGIFCONF",
        "SIOCGIFHWADDR",
        "SIOCGIFFLAGS",
        "SIOCSIFFLAGS",
        "SIOCGIFMTU",
        "SIOCSIFMTU",

        // Address families
        "AF_LINK",
        "AF_PACKET", // Only on Linux
    ];

    let snames = names
        .into_iter()
        .map(|x| String::from(*x))
        .collect::<Vec<String>>();
    data.insert("test_constants".to_string(), snames.to_json());

    // These constants are the same as above, but we don't test them for existence with #ifdef.
    let anames: &[&str] = &[
        "sizeof(struct ifreq)",
    ];
    let sanames = anames
        .into_iter()
        .map(|x| String::from(*x))
        .collect::<Vec<String>>();
    data.insert("always_constants".to_string(), sanames.to_json());

    data
}

#[derive(Debug)]
enum Error {
    IoError(io::Error),
    TemplateError(hbs::TemplateError),
    RenderError(hbs::RenderError)
}

impl From<io::Error> for Error {
    fn from(e: io::Error) -> Error {
        Error::IoError(e)
    }
}

impl From<hbs::TemplateError> for Error {
    fn from(e: hbs::TemplateError) -> Error {
        Error::TemplateError(e)
    }
}

impl From<hbs::RenderError> for Error {
    fn from(e: hbs::RenderError) -> Error {
        Error::RenderError(e)
    }
}
